
---
title: "decorate: <u>D</u>ifferential <u>E</u>pigenetic <u>Cor</u>egul<u>a</u>tion <u>Te</u>st"
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.Date()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{decorate: Differential Epigenetic Coregulation Test}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---

<!--- 
# run analysis
cd /Users/gabrielhoffman/workspace/repos/decorate/vignettes
# cd /hpc/users/hoffmg01/work/pinnacle/vignettes
# cd ~/work//decorate/
rmarkdown::render("decorate_example.Rmd", output_dir='./', intermediates_dir='./'); system("cat decorate_example.html | grep -v 'Found more than one class' | grep -v 'PythonEmbedInR' > decorate_example2.html")
--->

Standard analysis compares the differences in magnitude in epigenetic signal between two subsets of a dataset.  The decorate workflow evaluates the local correlation structure between nearby epigenetic features and identify clusters of features that are differential correlation between two subsets of a dataset.  Epigenetic datasets where decorate can be applied include ChIP-seq, ATAC-seq and DNA methylation.

decorate v`r packageVersion("decorate")`

# Workflow
\item 0) Data normalization and covariate correction

    + We assume this has already been perform using standard methods for your assay
    + decorate should be run on residuals after removing the effects of confounding variables

\item 1) Compute correlations between local pairs of features

    + `runOrderedClusteringGenome()`

\item 2) Perform hierarchical clustering of features

    + built into `runOrderedClusteringGenome()`

\item 3) Produce discrete clusters of features

    + `createClusters():` can take multiple parameter values to return multiple sets of clusters at different resolutions

\item 4) Filter clusters 

    - Based on strength of correlation
      + `scoreClusters():` evaluate the strength of the correlation structure of each cluster
      + `retainClusters():` identify clusters that pass a cutoff for strength of the correlation structure.  By default filters by LEF, the lead eigen-value fraction, which is the fraction of variance explained by the first eigen-value.  Higher LEF values indicate a stronger correlation structure.
      + `filterClusters():` apply filter to clusters based on this cutoff

    - Identify overlapping clusters and drop if redundant
      + `collapseClusters():` Collapse redundant clusters identified from using multiple parameter values in step (3).  Redundancy of two clusters is evaluated using the Jaccard index, the fraction of epigenetic features shared between two clusters.

\item 5) Statistical test of differential correlation 

    + `evalDiffCorr():` run permutations tests in parallel on multicore machine using the sparse leading eigen-value driven test (sLED).
    + the amount of regularization is determind with the parameter `sumabs.seq`, where a value of 1 is the least sparse and decreasing values result in more regularization.
    + see sLED [package](https://github.com/lingxuez/sLED) and [manuscript](https://arxiv.org/abs/1606.00252) for details of `adj.beta`, `rho` and `sumabs.seq` 

\item 6) Data visualization
    + `plotDecorate():` plot local correlation structure, clusters of features and genes in the region
    + `plotCompareCorr():` plot correlation structure for two subsets of the data


```{r load.packages, echo=FALSE, message=FALSE, results='hide'}
suppressPackageStartupMessages(library(knitr))

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=TRUE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE,
  cache.lazy = FALSE,
  dev = c("png", "pdf"), 
  fig.width=7, fig.height=7)

options(markdown.HTML.stylesheet = 'css/custom.css')
```

# Analysis of simulated data
```{r run.analysis, echo=TRUE, message=FALSE, results='hide'}
library(decorate)
library(GenomicRanges)
library(cowplot)     
library(EnsDb.Hsapiens.v86)

# load data
data('decorateData')

# load gene locations
# this is ENSEMBL v86 from the hg38 assembly
# but other versions and assemblies are available
ensdb = EnsDb.Hsapiens.v86

# Evaluate hierarchical clustering
# adjacentCount is the number of adjacent peaks considered in correlation
treeList = runOrderedClusteringGenome( simData, simLocation, adjacentCount=500 )

# Choose cutoffs and return clusters using multiple values for meanClusterSize 
# Clusters corresponding to each parameter value are returned 
# and then processed downstream
# By using multiple parameter values, epigenetic features are included in clusters 
# at different resolutions
treeListClusters = createClusters( treeList, method = "meanClusterSize", meanClusterSize=c(10, 30, 40, 50) )

# Evaluate strength of correlation for each cluster
clstScore = scoreClusters(treeList, treeListClusters )

# Filter to retain only strong clusters
# If lead eigen value fraction (LEF) > 30% then keep clusters
# LEF is the fraction of variance explained by the first eigen-value
clustInclude = retainClusters( clstScore, "LEF", 0.30 )

# get retained clusters
treeListClusters_filter = filterClusters( treeListClusters, clustInclude)

# collapse redundant clusters
treeListClusters_collapse = collapseClusters( treeListClusters_filter, simLocation, jaccardCutoff=0.9)

# Plot correlations and clusters in region defind by query
# get single entry giving range of the region
query = range(simLocation)  
```

### Summary of clustering
Number of cluster parameters: `r length(treeListClusters)`

+ `meanClusterSize=c(10, 30, 40, 50)`

Number of total clusters: `r countClusters(treeListClusters)`

+ in `treeListClusters`

Number of clusters after filtering: `r countClusters(treeListClusters_filter)`

+ in `treeListClusters_filter`

Number of clusters after collapsing: `r countClusters(treeListClusters_collapse)`

+ in `treeListClusters_collapse`

## Make plots
```{r plot2Decorate.text, eval=FALSE, echo=TRUE}
# A) plot all clusters
plotDecorate( ensdb, treeList, treeListClusters, simLocation, query )

# B) plot clusters after filtering
plotDecorate( ensdb, treeList, treeListClusters_filter, simLocation, query)
```

```{r plot2Decorate, fig.width=15, message=FALSE, results="hide", echo=FALSE}
fig1 = plotDecorate( ensdb, treeList, treeListClusters, simLocation, query)
fig2 = plotDecorate( ensdb, treeList, treeListClusters_filter, simLocation, query)
plot_grid( fig1, fig2, ncol=2, labels=c('A: All clusters', 'B: After filtering') )
```

## Plot after collapsing redundant clusters
```{r plotCollapse, eval=TRUE, message=FALSE, results="hide", echo=TRUE, eval=FALSE}
plotDecorate( ensdb, treeList, treeListClusters_collapse, simLocation, query)
```

```{r plotCollapse.2, message=FALSE, results="hide", echo=FALSE}
fig = plotDecorate( ensdb, treeList, treeListClusters_collapse, simLocation, query)
plot_grid( fig, ncol=1, labels=c('C: After collapsing clusters'), hjust=0 )
```

### Run test of differential correlation
Evaluate `treeListClusters_collapse`, the filtered collapsed set of clusters
```{r compare, echo=TRUE, message=FALSE, results="hide"}
# Evaluate Differential Correlation between two subsets of data
# increase npermute on real data
# Perform a minimum of 20 permutations and a max of 200 in first round
# For real data, add a 3rd value like 1e6 to perform a second round 
# of permutations in parallel
sledRes = evalDiffCorr( simData, metadata$Disease, simLocation, 
  treeListClusters_collapse, 
  npermute=c(20, 200, 2000))

# get summary of results
df = summary( sledRes )

# print results
head(df)
```
```{r print.table}
head(df)    
```
The id column gives the clustering parameter from `runOrderedClusteringGenome()`, so cluster 6 with id 10 is different from cluster 6 with id 50.
Note that n.perm can vary across clusters because decorate uses a data-adaptive method to select the number of permutations.  Decorate devotes more permutations to clusters with smaller p-values 

### Compare correlation structure in two subsets of the data
```{r plotCompareCorr, fig.width=4, echo=TRUE}
# extract feature identifiers from most significant cluster
peakIDs = getFeaturesInCluster( treeListClusters_collapse, df$chrom[1], df$cluster[1], df$id[1])

# plot comparison of correlation matrices for peaks in peakIDs
#  where data is subset by metadata$Disease
main = paste0(df$chrom[1], ': cluster ', df$cluster[1])
plotCompareCorr( simData, peakIDs, metadata$Disease) + ggtitle(main)
```







