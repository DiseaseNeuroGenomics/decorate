# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute correlations between pairs of features
#'
#' Compute correlations between pairs of features given in idxi and idxj
#'
#' @param Y matrix where columns are features
#' @param idxi indecies
#' @param idxj indecies
#' @param silent suppress messages 
#'
#' @return 
#' Compute local correlations between for all k: cor(Y[,idxi[k]], Y[,idxj[k]])
#' 
#' @examples
#' # Simulate simple dataset
#' N = 600
#' Y = matrix(rnorm(N*100), 100, N)
#' 
#' # select pairs to compute correlations between
#' i1 = sample.int(N, 200, replace=TRUE)
#' i2 = sample.int(N, 200, replace=TRUE)
#' 
#' # evaluate all piars
#' C = corSubsetPairs(Y, i1,i2)
#' 
#' # show value
#' C[i1[10], i2[10]]
#' 
#' # show values from evaluating this pair directly
#' cor(Y[,i1[10]], Y[,i2[10]])
#' 
#' @importFrom Rcpp evalCpp
#' @import RcppArmadillo
#' @importFrom Matrix sparseMatrix
#' @importFrom utils object.size
#' @export
corSubsetPairs <- function(Y, idxi, idxj, silent=FALSE) {

	# check function arguments

	# lengths of indecies must be equal
	if( length(idxi) != length(idxj) ){
		stop("Lengths of idxi and idxj must be equal: ", length(idxi) ,' != ', length(idxj))
	}

	# max index cannot be larger than ncol(Y)
	idx_range = range(c(idxi, idxj))
	if( idx_range[2] > ncol(Y) ){
		stop("Entry indxi or idxj exceeeds ncol(Y): ", idx_range[2] ,' > ', ncol(Y))
	}

	# min index must be greater than zero
	if( idx_range[1] <= 0 ){
		stop("Entry in indxi or idxj is <= 0: ", idx_range[1])
	}

	# Result is symmatric upper triangle, 
	# so any entries where i > j should be flipped
	# all pairs should be unique
	# df_idx = unique(t(apply(cbind(idxi, idxj), 1, function(x) sort(x))))
	# ============
	# sort
	vi = pmin(idxi, idxj)
	vj = pmax(idxi, idxj)

	# unique
	# *much* faster than using cbind and comparing rows of matrix
	unq = which(duplicated(paste(vi, vj)))
	if( length(unq) > 0){
		vi = vi[-unq]
		vj = vj[-unq]
	}

	# only computes crossprod(y1, y2)
	# This is only the correlation value if mean of cols is zero and 
	# sd == 1
    rho = .Call('_decorate_corSubsetPairs', PACKAGE = 'decorate', scale(Y), vi, vj)

    N = ncol(Y)
	sparsity = length(idxi) / N^2

	# Sparse symmetric matrix
	#   create symmetrics covariance matrix
	#   using only upper triangle
	#=======================================

	# if use.last.ij == FALSE, values at repeated indeces are summed
	# if TRUE, only use last value
	M = sparseMatrix( i = vi,
                j = vj,
                x = as.numeric(rho),
                dimnames = list(colnames(Y), colnames(Y)),
                dims = c(N,N), symmetric=TRUE)

	if( ! silent ){
		cat("Covariance matrix...\n")
		cat(" sparsity:", sprintf("%.3f%s", 100 - sparsity*100, ' %\n'))
		cat(" memory usage:", format(object.size(M), "MB"), '\n')
	}

	M
}










